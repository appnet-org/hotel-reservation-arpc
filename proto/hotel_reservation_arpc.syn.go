// Code generated by protoc-gen-arpc. DO NOT EDIT.
package hotel_reservation

import (
	"context"
	"github.com/appnet-org/arpc/pkg/rpc"
	"github.com/appnet-org/arpc/pkg/rpc/element"
)

// Service IDs
const (
	ServiceID_Geo            = 1
	ServiceID_Profile        = 2
	ServiceID_Recommendation = 3
	ServiceID_Rate           = 4
	ServiceID_Reservation    = 5
	ServiceID_Search         = 6
	ServiceID_User           = 7
)

// Service name <-> ID mappings
var serviceNameToID = map[string]uint32{
	"Geo":            ServiceID_Geo,
	"Profile":        ServiceID_Profile,
	"Recommendation": ServiceID_Recommendation,
	"Rate":           ServiceID_Rate,
	"Reservation":    ServiceID_Reservation,
	"Search":         ServiceID_Search,
	"User":           ServiceID_User,
}

var serviceIDToName = map[uint32]string{
	ServiceID_Geo:            "Geo",
	ServiceID_Profile:        "Profile",
	ServiceID_Recommendation: "Recommendation",
	ServiceID_Rate:           "Rate",
	ServiceID_Reservation:    "Reservation",
	ServiceID_Search:         "Search",
	ServiceID_User:           "User",
}

// Method IDs for Geo
const (
	Geo_MethodID_NearbyGeo = 1
)

// Method name <-> ID mappings for Geo
var Geo_methodNameToID = map[string]uint32{
	"NearbyGeo": Geo_MethodID_NearbyGeo,
}

var Geo_methodIDToName = map[uint32]string{
	Geo_MethodID_NearbyGeo: "NearbyGeo",
}

// GeoClient is the client API for Geo service.
type GeoClient interface {
	NearbyGeo(ctx context.Context, req *NearbyRequest) (*NearbyResult, error)
}

type arpcGeoClient struct {
	client *rpc.Client
}

func NewGeoClient(client *rpc.Client) GeoClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Geo", ServiceID_Geo, Geo_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcGeoClient{client: client}
}

func (c *arpcGeoClient) NearbyGeo(ctx context.Context, req *NearbyRequest) (*NearbyResult, error) {
	resp := new(NearbyResult)
	if err := c.client.Call(ctx, "Geo", "NearbyGeo", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type GeoServer interface {
	NearbyGeo(ctx context.Context, req *NearbyRequest) (*NearbyResult, context.Context, error)
}

func RegisterGeoServer(s *rpc.Server, srv GeoServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Geo",
		ServiceID:   ServiceID_Geo,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Geo_MethodID_NearbyGeo: {
				MethodName: "NearbyGeo",
				MethodID:   Geo_MethodID_NearbyGeo,
				Handler:    _Geo_NearbyGeo_Handler,
			},
		},
	}, srv)
}

func _Geo_NearbyGeo_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(NearbyRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(GeoServer).NearbyGeo(ctx, req.Payload.(*NearbyRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for Profile
const (
	Profile_MethodID_GetProfiles = 1
)

// Method name <-> ID mappings for Profile
var Profile_methodNameToID = map[string]uint32{
	"GetProfiles": Profile_MethodID_GetProfiles,
}

var Profile_methodIDToName = map[uint32]string{
	Profile_MethodID_GetProfiles: "GetProfiles",
}

// ProfileClient is the client API for Profile service.
type ProfileClient interface {
	GetProfiles(ctx context.Context, req *GetProfilesRequest) (*GetProfilesResult, error)
}

type arpcProfileClient struct {
	client *rpc.Client
}

func NewProfileClient(client *rpc.Client) ProfileClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Profile", ServiceID_Profile, Profile_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcProfileClient{client: client}
}

func (c *arpcProfileClient) GetProfiles(ctx context.Context, req *GetProfilesRequest) (*GetProfilesResult, error) {
	resp := new(GetProfilesResult)
	if err := c.client.Call(ctx, "Profile", "GetProfiles", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type ProfileServer interface {
	GetProfiles(ctx context.Context, req *GetProfilesRequest) (*GetProfilesResult, context.Context, error)
}

func RegisterProfileServer(s *rpc.Server, srv ProfileServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Profile",
		ServiceID:   ServiceID_Profile,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Profile_MethodID_GetProfiles: {
				MethodName: "GetProfiles",
				MethodID:   Profile_MethodID_GetProfiles,
				Handler:    _Profile_GetProfiles_Handler,
			},
		},
	}, srv)
}

func _Profile_GetProfiles_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(GetProfilesRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(ProfileServer).GetProfiles(ctx, req.Payload.(*GetProfilesRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for Recommendation
const (
	Recommendation_MethodID_GetRecommendations = 1
)

// Method name <-> ID mappings for Recommendation
var Recommendation_methodNameToID = map[string]uint32{
	"GetRecommendations": Recommendation_MethodID_GetRecommendations,
}

var Recommendation_methodIDToName = map[uint32]string{
	Recommendation_MethodID_GetRecommendations: "GetRecommendations",
}

// RecommendationClient is the client API for Recommendation service.
type RecommendationClient interface {
	GetRecommendations(ctx context.Context, req *GetRecommendationsRequest) (*GetRecommendationsResult, error)
}

type arpcRecommendationClient struct {
	client *rpc.Client
}

func NewRecommendationClient(client *rpc.Client) RecommendationClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Recommendation", ServiceID_Recommendation, Recommendation_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcRecommendationClient{client: client}
}

func (c *arpcRecommendationClient) GetRecommendations(ctx context.Context, req *GetRecommendationsRequest) (*GetRecommendationsResult, error) {
	resp := new(GetRecommendationsResult)
	if err := c.client.Call(ctx, "Recommendation", "GetRecommendations", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type RecommendationServer interface {
	GetRecommendations(ctx context.Context, req *GetRecommendationsRequest) (*GetRecommendationsResult, context.Context, error)
}

func RegisterRecommendationServer(s *rpc.Server, srv RecommendationServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Recommendation",
		ServiceID:   ServiceID_Recommendation,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Recommendation_MethodID_GetRecommendations: {
				MethodName: "GetRecommendations",
				MethodID:   Recommendation_MethodID_GetRecommendations,
				Handler:    _Recommendation_GetRecommendations_Handler,
			},
		},
	}, srv)
}

func _Recommendation_GetRecommendations_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(GetRecommendationsRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(RecommendationServer).GetRecommendations(ctx, req.Payload.(*GetRecommendationsRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for Rate
const (
	Rate_MethodID_GetRates = 1
)

// Method name <-> ID mappings for Rate
var Rate_methodNameToID = map[string]uint32{
	"GetRates": Rate_MethodID_GetRates,
}

var Rate_methodIDToName = map[uint32]string{
	Rate_MethodID_GetRates: "GetRates",
}

// RateClient is the client API for Rate service.
type RateClient interface {
	GetRates(ctx context.Context, req *GetRatesRequest) (*GetRatesResult, error)
}

type arpcRateClient struct {
	client *rpc.Client
}

func NewRateClient(client *rpc.Client) RateClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Rate", ServiceID_Rate, Rate_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcRateClient{client: client}
}

func (c *arpcRateClient) GetRates(ctx context.Context, req *GetRatesRequest) (*GetRatesResult, error) {
	resp := new(GetRatesResult)
	if err := c.client.Call(ctx, "Rate", "GetRates", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type RateServer interface {
	GetRates(ctx context.Context, req *GetRatesRequest) (*GetRatesResult, context.Context, error)
}

func RegisterRateServer(s *rpc.Server, srv RateServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Rate",
		ServiceID:   ServiceID_Rate,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Rate_MethodID_GetRates: {
				MethodName: "GetRates",
				MethodID:   Rate_MethodID_GetRates,
				Handler:    _Rate_GetRates_Handler,
			},
		},
	}, srv)
}

func _Rate_GetRates_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(GetRatesRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(RateServer).GetRates(ctx, req.Payload.(*GetRatesRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for Reservation
const (
	Reservation_MethodID_MakeReservation   = 1
	Reservation_MethodID_CheckAvailability = 2
)

// Method name <-> ID mappings for Reservation
var Reservation_methodNameToID = map[string]uint32{
	"MakeReservation":   Reservation_MethodID_MakeReservation,
	"CheckAvailability": Reservation_MethodID_CheckAvailability,
}

var Reservation_methodIDToName = map[uint32]string{
	Reservation_MethodID_MakeReservation:   "MakeReservation",
	Reservation_MethodID_CheckAvailability: "CheckAvailability",
}

// ReservationClient is the client API for Reservation service.
type ReservationClient interface {
	MakeReservation(ctx context.Context, req *ReservationRequest) (*ReservationResult, error)
	CheckAvailability(ctx context.Context, req *ReservationRequest) (*ReservationResult, error)
}

type arpcReservationClient struct {
	client *rpc.Client
}

func NewReservationClient(client *rpc.Client) ReservationClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Reservation", ServiceID_Reservation, Reservation_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcReservationClient{client: client}
}

func (c *arpcReservationClient) MakeReservation(ctx context.Context, req *ReservationRequest) (*ReservationResult, error) {
	resp := new(ReservationResult)
	if err := c.client.Call(ctx, "Reservation", "MakeReservation", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *arpcReservationClient) CheckAvailability(ctx context.Context, req *ReservationRequest) (*ReservationResult, error) {
	resp := new(ReservationResult)
	if err := c.client.Call(ctx, "Reservation", "CheckAvailability", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type ReservationServer interface {
	MakeReservation(ctx context.Context, req *ReservationRequest) (*ReservationResult, context.Context, error)
	CheckAvailability(ctx context.Context, req *ReservationRequest) (*ReservationResult, context.Context, error)
}

func RegisterReservationServer(s *rpc.Server, srv ReservationServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Reservation",
		ServiceID:   ServiceID_Reservation,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Reservation_MethodID_MakeReservation: {
				MethodName: "MakeReservation",
				MethodID:   Reservation_MethodID_MakeReservation,
				Handler:    _Reservation_MakeReservation_Handler,
			},
			Reservation_MethodID_CheckAvailability: {
				MethodName: "CheckAvailability",
				MethodID:   Reservation_MethodID_CheckAvailability,
				Handler:    _Reservation_CheckAvailability_Handler,
			},
		},
	}, srv)
}

func _Reservation_MakeReservation_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(ReservationRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(ReservationServer).MakeReservation(ctx, req.Payload.(*ReservationRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

func _Reservation_CheckAvailability_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(ReservationRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(ReservationServer).CheckAvailability(ctx, req.Payload.(*ReservationRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for Search
const (
	Search_MethodID_Nearby = 1
)

// Method name <-> ID mappings for Search
var Search_methodNameToID = map[string]uint32{
	"Nearby": Search_MethodID_Nearby,
}

var Search_methodIDToName = map[uint32]string{
	Search_MethodID_Nearby: "Nearby",
}

// SearchClient is the client API for Search service.
type SearchClient interface {
	Nearby(ctx context.Context, req *SearchRequest) (*SearchResult, error)
}

type arpcSearchClient struct {
	client *rpc.Client
}

func NewSearchClient(client *rpc.Client) SearchClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("Search", ServiceID_Search, Search_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcSearchClient{client: client}
}

func (c *arpcSearchClient) Nearby(ctx context.Context, req *SearchRequest) (*SearchResult, error) {
	resp := new(SearchResult)
	if err := c.client.Call(ctx, "Search", "Nearby", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type SearchServer interface {
	Nearby(ctx context.Context, req *SearchRequest) (*SearchResult, context.Context, error)
}

func RegisterSearchServer(s *rpc.Server, srv SearchServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "Search",
		ServiceID:   ServiceID_Search,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			Search_MethodID_Nearby: {
				MethodName: "Nearby",
				MethodID:   Search_MethodID_Nearby,
				Handler:    _Search_Nearby_Handler,
			},
		},
	}, srv)
}

func _Search_Nearby_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(SearchRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(SearchServer).Nearby(ctx, req.Payload.(*SearchRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}

// Method IDs for User
const (
	User_MethodID_CheckUser = 1
)

// Method name <-> ID mappings for User
var User_methodNameToID = map[string]uint32{
	"CheckUser": User_MethodID_CheckUser,
}

var User_methodIDToName = map[uint32]string{
	User_MethodID_CheckUser: "CheckUser",
}

// UserClient is the client API for User service.
type UserClient interface {
	CheckUser(ctx context.Context, req *CheckUserRequest) (*CheckUserResult, error)
}

type arpcUserClient struct {
	client *rpc.Client
}

func NewUserClient(client *rpc.Client) UserClient {
	// Create and register service registry
	registry := rpc.NewServiceRegistry()
	registry.RegisterService("User", ServiceID_User, User_methodNameToID)
	client.SetServiceRegistry(registry)
	return &arpcUserClient{client: client}
}

func (c *arpcUserClient) CheckUser(ctx context.Context, req *CheckUserRequest) (*CheckUserResult, error) {
	resp := new(CheckUserResult)
	if err := c.client.Call(ctx, "User", "CheckUser", req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type UserServer interface {
	CheckUser(ctx context.Context, req *CheckUserRequest) (*CheckUserResult, context.Context, error)
}

func RegisterUserServer(s *rpc.Server, srv UserServer) {
	s.RegisterService(&rpc.ServiceDesc{
		ServiceName: "User",
		ServiceID:   ServiceID_User,
		ServiceImpl: srv,
		MethodsByID: map[uint32]*rpc.MethodDesc{
			User_MethodID_CheckUser: {
				MethodName: "CheckUser",
				MethodID:   User_MethodID_CheckUser,
				Handler:    _User_CheckUser_Handler,
			},
		},
	}, srv)
}

func _User_CheckUser_Handler(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {
	req.Payload = new(CheckUserRequest)
	if err := dec(req.Payload); err != nil {
		return nil, ctx, err
	}
	req, ctx, err := chain.ProcessRequest(ctx, req)
	if err != nil {
		return nil, ctx, err
	}
	result, ctx, err := srv.(UserServer).CheckUser(ctx, req.Payload.(*CheckUserRequest))
	if err != nil {
		return nil, ctx, err
	}
	resp := &element.RPCResponse{
		ID:     req.ID,
		Result: result,
	}
	resp, ctx, err = chain.ProcessResponse(ctx, resp)
	if err != nil {
		return nil, ctx, err
	}
	return resp, ctx, err
}
