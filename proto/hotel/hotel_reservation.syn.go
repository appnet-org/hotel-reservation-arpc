// Code generated by protoc-gen-symphony. DO NOT EDIT.
package hotel_reservation

import (
	"encoding/binary"
	"fmt"
	math "math"
)

func (m *NearbyRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 61)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Lat

	offset += 4 // Lon

	// Field 3 (Latstring): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Latstring
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Latstring)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Latstring)

	// === DATA REGION SECTION ===

	// Write fixed field (Lat)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lat))
	buf = append(buf, temp[:4]...)

	// Write fixed field (Lon)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lon))
	buf = append(buf, temp[:4]...)

	// Write string or bytes field (Latstring)
	buf = append(buf, []byte(m.Latstring)...)

	return buf, nil
}

func (m *NearbyRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Lat
			// Unmarshal fixed field (Lat)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lat = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 2: // Lon
			// Unmarshal fixed field (Lon)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lon = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 3: // Latstring
			// Unmarshal string or []byte field (Latstring)
			if entry, ok := offsets[3]; ok {
				m.Latstring = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *NearbyResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *NearbyResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProfilesRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// Field 2 (Locale): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Locale
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Locale)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Locale)

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	// Write string or bytes field (Locale)
	buf = append(buf, []byte(m.Locale)...)

	return buf, nil
}

func (m *GetProfilesRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		case 2: // Locale
			// Unmarshal string or []byte field (Locale)
			if entry, ok := offsets[2]; ok {
				m.Locale = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProfilesResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Hotels): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Hotels))
	for i, item := range m.Hotels {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Hotels[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Hotels): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Hotels)
	for _, item := range cachedRepeatedMessages[1] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *GetProfilesResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Hotels
			// Unmarshal nested message field (Hotels)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Hotels = make([]*Hotel, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Hotels = append(m.Hotels, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &Hotel{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Hotels = append(m.Hotels, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Hotel) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 366)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5, 6}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[5], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Address: %w", err)
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 6 (Images): repeated message
	cachedRepeatedMessages[6] = make([][]byte, len(m.Images))
	for i, item := range m.Images {
		if item != nil {
			cachedRepeatedMessages[6][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field Images[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Id
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Id)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Id)

	// Field 2 (Name): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Name
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Name)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Name)

	// Field 3 (PhoneNumber): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of PhoneNumber
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.PhoneNumber)))
	buf = append(buf, temp[:2]...)
	offset += len(m.PhoneNumber)

	// Field 4 (Description): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Description
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Description)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Description)

	// Field 5 (Address): nested message
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[5])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[5])

	// Field 6 (Images): nested message
	buf = append(buf, byte(6))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[6] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf = append(buf, []byte(m.Id)...)

	// Write string or bytes field (Name)
	buf = append(buf, []byte(m.Name)...)

	// Write string or bytes field (PhoneNumber)
	buf = append(buf, []byte(m.PhoneNumber)...)

	// Write string or bytes field (Description)
	buf = append(buf, []byte(m.Description)...)

	// Write nested message field (Address)
	buf = append(buf, cachedSingularMessages[5]...)

	// Write nested message field (Images)
	for _, item := range cachedRepeatedMessages[6] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *Hotel) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 7 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+6]
	offset += 6

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 30
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 6; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Name
			// Unmarshal string or []byte field (Name)
			if entry, ok := offsets[2]; ok {
				m.Name = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // PhoneNumber
			// Unmarshal string or []byte field (PhoneNumber)
			if entry, ok := offsets[3]; ok {
				m.PhoneNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // Description
			// Unmarshal string or []byte field (Description)
			if entry, ok := offsets[4]; ok {
				m.Description = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 6: // Images
			// Unmarshal nested message field (Images)
			if entry, ok := offsets[6]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Images = make([]*Image, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.Images = append(m.Images, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &Image{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.Images = append(m.Images, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Address) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 298)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5, 6, 7, 8}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (StreetNumber): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of StreetNumber
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.StreetNumber)))
	buf = append(buf, temp[:2]...)
	offset += len(m.StreetNumber)

	// Field 2 (StreetName): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of StreetName
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.StreetName)))
	buf = append(buf, temp[:2]...)
	offset += len(m.StreetName)

	// Field 3 (City): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of City
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.City)))
	buf = append(buf, temp[:2]...)
	offset += len(m.City)

	// Field 4 (State): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of State
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.State)))
	buf = append(buf, temp[:2]...)
	offset += len(m.State)

	// Field 5 (Country): string or bytes
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Country
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Country)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Country)

	// Field 6 (PostalCode): string or bytes
	buf = append(buf, byte(6))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of PostalCode
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.PostalCode)))
	buf = append(buf, temp[:2]...)
	offset += len(m.PostalCode)

	offset += 4 // Lat

	offset += 4 // Lon

	// === DATA REGION SECTION ===

	// Write string or bytes field (StreetNumber)
	buf = append(buf, []byte(m.StreetNumber)...)

	// Write string or bytes field (StreetName)
	buf = append(buf, []byte(m.StreetName)...)

	// Write string or bytes field (City)
	buf = append(buf, []byte(m.City)...)

	// Write string or bytes field (State)
	buf = append(buf, []byte(m.State)...)

	// Write string or bytes field (Country)
	buf = append(buf, []byte(m.Country)...)

	// Write string or bytes field (PostalCode)
	buf = append(buf, []byte(m.PostalCode)...)

	// Write fixed field (Lat)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lat))
	buf = append(buf, temp[:4]...)

	// Write fixed field (Lon)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lon))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *Address) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 9 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+8]
	offset += 8

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 30
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 6; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // StreetNumber
			// Unmarshal string or []byte field (StreetNumber)
			if entry, ok := offsets[1]; ok {
				m.StreetNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // StreetName
			// Unmarshal string or []byte field (StreetName)
			if entry, ok := offsets[2]; ok {
				m.StreetName = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // City
			// Unmarshal string or []byte field (City)
			if entry, ok := offsets[3]; ok {
				m.City = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // State
			// Unmarshal string or []byte field (State)
			if entry, ok := offsets[4]; ok {
				m.State = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // Country
			// Unmarshal string or []byte field (Country)
			if entry, ok := offsets[5]; ok {
				m.Country = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 6: // PostalCode
			// Unmarshal string or []byte field (PostalCode)
			if entry, ok := offsets[6]; ok {
				m.PostalCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 7: // Lat
			// Unmarshal fixed field (Lat)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lat = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 8: // Lon
			// Unmarshal fixed field (Lon)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lon = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *Image) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 51)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Url): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Url
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Url)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Url)

	offset += 1 // Default

	// === DATA REGION SECTION ===

	// Write string or bytes field (Url)
	buf = append(buf, []byte(m.Url)...)

	// Write fixed field (Default)
	if m.Default {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}

	return buf, nil
}

func (m *Image) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Url
			// Unmarshal string or []byte field (Url)
			if entry, ok := offsets[1]; ok {
				m.Url = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Default
			// Unmarshal fixed field (Default)
			if dataOffset+1 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Default = dataRegion[dataOffset] != 0
			dataOffset += 1
		}
	}

	return nil
}

func (m *GetRecommendationsRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 71)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Require): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Require
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Require)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Require)

	offset += 8 // Lat

	offset += 8 // Lon

	// === DATA REGION SECTION ===

	// Write string or bytes field (Require)
	buf = append(buf, []byte(m.Require)...)

	// Write fixed field (Lat)
	binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(m.Lat))
	buf = append(buf, temp[:8]...)

	// Write fixed field (Lon)
	binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(m.Lon))
	buf = append(buf, temp[:8]...)

	return buf, nil
}

func (m *GetRecommendationsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Require
			// Unmarshal string or []byte field (Require)
			if entry, ok := offsets[1]; ok {
				m.Require = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Lat
			// Unmarshal fixed field (Lat)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lat = math.Float64frombits(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		case 3: // Lon
			// Unmarshal fixed field (Lon)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lon = math.Float64frombits(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		}
	}

	return nil
}

func (m *GetRecommendationsResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *GetRecommendationsResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetRatesRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 143)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// Field 2 (InDate): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of InDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.InDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.InDate)

	// Field 3 (OutDate): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of OutDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.OutDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.OutDate)

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	// Write string or bytes field (InDate)
	buf = append(buf, []byte(m.InDate)...)

	// Write string or bytes field (OutDate)
	buf = append(buf, []byte(m.OutDate)...)

	return buf, nil
}

func (m *GetRatesRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 15
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 3; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		case 2: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[2]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[3]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetRatesResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 88)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (RatePlans): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.RatePlans))
	for i, item := range m.RatePlans {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, fmt.Errorf("failed to marshal repeated message field RatePlans[%d]: %w", i, err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (RatePlans): nested message
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (RatePlans)
	for _, item := range cachedRepeatedMessages[1] {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, item...)
	}

	return buf, nil
}

func (m *GetRatesResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // RatePlans
			// Unmarshal nested message field (RatePlans)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.RatePlans = make([]*RatePlan, 0)
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.RatePlans = append(m.RatePlans, nil)
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item bytes")
					}
					itemBytes := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					newItem := &RatePlan{}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return fmt.Errorf("failed to unmarshal nested message: %w", err)
					}
					m.RatePlans = append(m.RatePlans, newItem)
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RatePlan) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 278)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (RoomType): singular message
	if m.RoomType != nil {
		cachedSingularMessages[5], err = m.RoomType.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field RoomType: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelId): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelId
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.HotelId)))
	buf = append(buf, temp[:2]...)
	offset += len(m.HotelId)

	// Field 2 (Code): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Code
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Code)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Code)

	// Field 3 (InDate): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of InDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.InDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of OutDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.OutDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.OutDate)

	// Field 5 (RoomType): nested message
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[5])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[5])

	// === DATA REGION SECTION ===

	// Write string or bytes field (HotelId)
	buf = append(buf, []byte(m.HotelId)...)

	// Write string or bytes field (Code)
	buf = append(buf, []byte(m.Code)...)

	// Write string or bytes field (InDate)
	buf = append(buf, []byte(m.InDate)...)

	// Write string or bytes field (OutDate)
	buf = append(buf, []byte(m.OutDate)...)

	// Write nested message field (RoomType)
	buf = append(buf, cachedSingularMessages[5]...)

	return buf, nil
}

func (m *RatePlan) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 6 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+5]
	offset += 5

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 25
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 5; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelId
			// Unmarshal string or []byte field (HotelId)
			if entry, ok := offsets[1]; ok {
				m.HotelId = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Code
			// Unmarshal string or []byte field (Code)
			if entry, ok := offsets[2]; ok {
				m.Code = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // RoomType
			// Unmarshal nested message field (RoomType)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.RoomType = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.RoomType == nil {
						m.RoomType = &RoomType{}
					}
					if err := m.RoomType.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RoomType) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 177)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5, 6}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 8 // BookableRate

	offset += 8 // TotalRate

	offset += 8 // TotalRateInclusive

	// Field 4 (Code): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Code
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Code)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Code)

	// Field 5 (Currency): string or bytes
	buf = append(buf, byte(5))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Currency
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Currency)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Currency)

	// Field 6 (RoomDescription): string or bytes
	buf = append(buf, byte(6))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of RoomDescription
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.RoomDescription)))
	buf = append(buf, temp[:2]...)
	offset += len(m.RoomDescription)

	// === DATA REGION SECTION ===

	// Write fixed field (BookableRate)
	binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(m.BookableRate))
	buf = append(buf, temp[:8]...)

	// Write fixed field (TotalRate)
	binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(m.TotalRate))
	buf = append(buf, temp[:8]...)

	// Write fixed field (TotalRateInclusive)
	binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(m.TotalRateInclusive))
	buf = append(buf, temp[:8]...)

	// Write string or bytes field (Code)
	buf = append(buf, []byte(m.Code)...)

	// Write string or bytes field (Currency)
	buf = append(buf, []byte(m.Currency)...)

	// Write string or bytes field (RoomDescription)
	buf = append(buf, []byte(m.RoomDescription)...)

	return buf, nil
}

func (m *RoomType) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 7 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+6]
	offset += 6

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 15
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 3; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // BookableRate
			// Unmarshal fixed field (BookableRate)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.BookableRate = math.Float64frombits(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		case 2: // TotalRate
			// Unmarshal fixed field (TotalRate)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.TotalRate = math.Float64frombits(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		case 3: // TotalRateInclusive
			// Unmarshal fixed field (TotalRateInclusive)
			if dataOffset+8 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.TotalRateInclusive = math.Float64frombits(binary.LittleEndian.Uint64(dataRegion[dataOffset : dataOffset+8]))
			dataOffset += 8
		case 4: // Code
			// Unmarshal string or []byte field (Code)
			if entry, ok := offsets[4]; ok {
				m.Code = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // Currency
			// Unmarshal string or []byte field (Currency)
			if entry, ok := offsets[5]; ok {
				m.Currency = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 6: // RoomDescription
			// Unmarshal string or []byte field (RoomDescription)
			if entry, ok := offsets[6]; ok {
				m.RoomDescription = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ReservationRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 197)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4, 5}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CustomerName): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of CustomerName
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.CustomerName)))
	buf = append(buf, temp[:2]...)
	offset += len(m.CustomerName)

	// Field 2 (HotelId): repeated variable-length
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelId
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelId {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// Field 3 (InDate): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of InDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.InDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of OutDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.OutDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.OutDate)

	offset += 4 // RoomNumber

	// === DATA REGION SECTION ===

	// Write string or bytes field (CustomerName)
	buf = append(buf, []byte(m.CustomerName)...)

	// Write repeated variable-length field (HotelId)
	for _, item := range m.HotelId {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	// Write string or bytes field (InDate)
	buf = append(buf, []byte(m.InDate)...)

	// Write string or bytes field (OutDate)
	buf = append(buf, []byte(m.OutDate)...)

	// Write fixed field (RoomNumber)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.RoomNumber))
	buf = append(buf, temp[:4]...)

	return buf, nil
}

func (m *ReservationRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 6 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+5]
	offset += 5

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 20
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 4; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CustomerName
			// Unmarshal string or []byte field (CustomerName)
			if entry, ok := offsets[1]; ok {
				m.CustomerName = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // HotelId
			// Unmarshal repeated variable-length field (HotelId)
			if entry, ok := offsets[2]; ok {
				m.HotelId = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelId = append(m.HotelId, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelId = append(m.HotelId, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 5: // RoomNumber
			// Unmarshal fixed field (RoomNumber)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.RoomNumber = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		}
	}

	return nil
}

func (m *ReservationResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelId): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelId
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelId {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelId)
	for _, item := range m.HotelId {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *ReservationResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelId
			// Unmarshal repeated variable-length field (HotelId)
			if entry, ok := offsets[1]; ok {
				m.HotelId = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelId = append(m.HotelId, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelId = append(m.HotelId, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 108)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Lat

	offset += 4 // Lon

	// Field 3 (InDate): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of InDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.InDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of OutDate
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.OutDate)))
	buf = append(buf, temp[:2]...)
	offset += len(m.OutDate)

	// === DATA REGION SECTION ===

	// Write fixed field (Lat)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lat))
	buf = append(buf, temp[:4]...)

	// Write fixed field (Lon)
	binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(m.Lon))
	buf = append(buf, temp[:4]...)

	// Write string or bytes field (InDate)
	buf = append(buf, []byte(m.InDate)...)

	// Write string or bytes field (OutDate)
	buf = append(buf, []byte(m.OutDate)...)

	return buf, nil
}

func (m *SearchRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 5 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+4]
	offset += 4

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Lat
			// Unmarshal fixed field (Lat)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lat = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 2: // Lon
			// Unmarshal fixed field (Lon)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Lon = math.Float32frombits(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of HotelIds
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *SearchResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CheckUserRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Username): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Username
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Username)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Username)

	// Field 2 (Password): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Password
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Password)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Password)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Username)
	buf = append(buf, []byte(m.Username)...)

	// Write string or bytes field (Password)
	buf = append(buf, []byte(m.Password)...)

	return buf, nil
}

func (m *CheckUserRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Username
			// Unmarshal string or []byte field (Username)
			if entry, ok := offsets[1]; ok {
				m.Username = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Password
			// Unmarshal string or []byte field (Password)
			if entry, ok := offsets[2]; ok {
				m.Password = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CheckUserResult) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 3)

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 1 // Correct

	// === DATA REGION SECTION ===

	// Write fixed field (Correct)
	if m.Correct {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}

	return buf, nil
}

func (m *CheckUserResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Correct
			// Unmarshal fixed field (Correct)
			if dataOffset+1 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Correct = dataRegion[dataOffset] != 0
			dataOffset += 1
		}
	}

	return nil
}
