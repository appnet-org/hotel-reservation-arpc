// Code generated by protoc-gen-symphony. DO NOT EDIT.
package hotel_reservation

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func (m *NearbyRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3})

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Lat

	offset += 4 // Lon

	// Field 3 (Latstring): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Latstring
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Latstring)))
	offset += len(m.Latstring)

	// === DATA REGION SECTION ===

	// Write fixed field (Lat)
	binary.Write(&buf, binary.LittleEndian, m.Lat)

	// Write fixed field (Lon)
	binary.Write(&buf, binary.LittleEndian, m.Lon)

	// Write string or bytes field (Latstring)
	buf.Write([]byte(m.Latstring))

	return buf.Bytes(), nil
}

func (m *NearbyRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 3)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Lat
			// Unmarshal fixed field (Lat)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lat); err != nil {
				return err
			}
			offset += 4
		case 2: // Lon
			// Unmarshal fixed field (Lon)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lon); err != nil {
				return err
			}
			offset += 4
		case 3: // Latstring
			// Unmarshal string or []byte field (Latstring)
			if entry, ok := offsets[3]; ok {
				m.Latstring = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *NearbyResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *NearbyResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item data: %w", err)
					}
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProfilesRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// Field 2 (Locale): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Locale
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Locale)))
	offset += len(m.Locale)

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	// Write string or bytes field (Locale)
	buf.Write([]byte(m.Locale))

	return buf.Bytes(), nil
}

func (m *GetProfilesRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item data: %w", err)
					}
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				offset += int(entry.length)
			}
		case 2: // Locale
			// Unmarshal string or []byte field (Locale)
			if entry, ok := offsets[2]; ok {
				m.Locale = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetProfilesResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (Hotels): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.Hotels))
	for i, item := range m.Hotels {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Hotels): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (Hotels)
	for _, item := range cachedRepeatedMessages[1] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *GetProfilesResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Hotels
			// Unmarshal nested message field (Hotels)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Hotels = make([]*Hotel, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &Hotel{}
					if itemLen == 0 {
						m.Hotels = append(m.Hotels, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Hotels = append(m.Hotels, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Hotel) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5, 6})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (Address): singular message
	if m.Address != nil {
		cachedSingularMessages[5], err = m.Address.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 6 (Images): repeated message
	cachedRepeatedMessages[6] = make([][]byte, len(m.Images))
	for i, item := range m.Images {
		if item != nil {
			cachedRepeatedMessages[6][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Id): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Id
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Id)))
	offset += len(m.Id)

	// Field 2 (Name): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Name
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Name)))
	offset += len(m.Name)

	// Field 3 (PhoneNumber): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of PhoneNumber
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.PhoneNumber)))
	offset += len(m.PhoneNumber)

	// Field 4 (Description): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Description
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Description)))
	offset += len(m.Description)

	// Field 5 (Address): nested message
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[5])))
	offset += len(cachedSingularMessages[5])

	// Field 6 (Images): nested message
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[6] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (Id)
	buf.Write([]byte(m.Id))

	// Write string or bytes field (Name)
	buf.Write([]byte(m.Name))

	// Write string or bytes field (PhoneNumber)
	buf.Write([]byte(m.PhoneNumber))

	// Write string or bytes field (Description)
	buf.Write([]byte(m.Description))

	// Write nested message field (Address)
	buf.Write(cachedSingularMessages[5])

	// Write nested message field (Images)
	for _, item := range cachedRepeatedMessages[6] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *Hotel) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 6)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 6; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal string or []byte field (Id)
			if entry, ok := offsets[1]; ok {
				m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Name
			// Unmarshal string or []byte field (Name)
			if entry, ok := offsets[2]; ok {
				m.Name = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // PhoneNumber
			// Unmarshal string or []byte field (PhoneNumber)
			if entry, ok := offsets[3]; ok {
				m.PhoneNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // Description
			// Unmarshal string or []byte field (Description)
			if entry, ok := offsets[4]; ok {
				m.Description = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // Address
			// Unmarshal nested message field (Address)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.Address = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Address == nil {
						m.Address = &Address{}
					}
					if err := m.Address.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		case 6: // Images
			// Unmarshal nested message field (Images)
			if entry, ok := offsets[6]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.Images = make([]*Image, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &Image{}
					if itemLen == 0 {
						m.Images = append(m.Images, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.Images = append(m.Images, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *Address) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5, 6, 7, 8})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (StreetNumber): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of StreetNumber
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.StreetNumber)))
	offset += len(m.StreetNumber)

	// Field 2 (StreetName): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of StreetName
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.StreetName)))
	offset += len(m.StreetName)

	// Field 3 (City): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of City
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.City)))
	offset += len(m.City)

	// Field 4 (State): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of State
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.State)))
	offset += len(m.State)

	// Field 5 (Country): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Country
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Country)))
	offset += len(m.Country)

	// Field 6 (PostalCode): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of PostalCode
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.PostalCode)))
	offset += len(m.PostalCode)

	offset += 4 // Lat

	offset += 4 // Lon

	// === DATA REGION SECTION ===

	// Write string or bytes field (StreetNumber)
	buf.Write([]byte(m.StreetNumber))

	// Write string or bytes field (StreetName)
	buf.Write([]byte(m.StreetName))

	// Write string or bytes field (City)
	buf.Write([]byte(m.City))

	// Write string or bytes field (State)
	buf.Write([]byte(m.State))

	// Write string or bytes field (Country)
	buf.Write([]byte(m.Country))

	// Write string or bytes field (PostalCode)
	buf.Write([]byte(m.PostalCode))

	// Write fixed field (Lat)
	binary.Write(&buf, binary.LittleEndian, m.Lat)

	// Write fixed field (Lon)
	binary.Write(&buf, binary.LittleEndian, m.Lon)

	return buf.Bytes(), nil
}

func (m *Address) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 8)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 6; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // StreetNumber
			// Unmarshal string or []byte field (StreetNumber)
			if entry, ok := offsets[1]; ok {
				m.StreetNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // StreetName
			// Unmarshal string or []byte field (StreetName)
			if entry, ok := offsets[2]; ok {
				m.StreetName = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // City
			// Unmarshal string or []byte field (City)
			if entry, ok := offsets[3]; ok {
				m.City = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // State
			// Unmarshal string or []byte field (State)
			if entry, ok := offsets[4]; ok {
				m.State = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // Country
			// Unmarshal string or []byte field (Country)
			if entry, ok := offsets[5]; ok {
				m.Country = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 6: // PostalCode
			// Unmarshal string or []byte field (PostalCode)
			if entry, ok := offsets[6]; ok {
				m.PostalCode = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 7: // Lat
			// Unmarshal fixed field (Lat)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lat); err != nil {
				return err
			}
			offset += 4
		case 8: // Lon
			// Unmarshal fixed field (Lon)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lon); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *Image) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Url): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Url
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Url)))
	offset += len(m.Url)

	offset += 1 // Default

	// === DATA REGION SECTION ===

	// Write string or bytes field (Url)
	buf.Write([]byte(m.Url))

	// Write fixed field (Default)
	binary.Write(&buf, binary.LittleEndian, m.Default)

	return buf.Bytes(), nil
}

func (m *Image) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Url
			// Unmarshal string or []byte field (Url)
			if entry, ok := offsets[1]; ok {
				m.Url = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Default
			// Unmarshal fixed field (Default)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+1]), binary.LittleEndian, &m.Default); err != nil {
				return err
			}
			offset += 1
		}
	}

	return nil
}

func (m *GetRecommendationsRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Require): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Require
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Require)))
	offset += len(m.Require)

	offset += 8 // Lat

	offset += 8 // Lon

	// === DATA REGION SECTION ===

	// Write string or bytes field (Require)
	buf.Write([]byte(m.Require))

	// Write fixed field (Lat)
	binary.Write(&buf, binary.LittleEndian, m.Lat)

	// Write fixed field (Lon)
	binary.Write(&buf, binary.LittleEndian, m.Lon)

	return buf.Bytes(), nil
}

func (m *GetRecommendationsRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 3)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Require
			// Unmarshal string or []byte field (Require)
			if entry, ok := offsets[1]; ok {
				m.Require = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Lat
			// Unmarshal fixed field (Lat)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.Lat); err != nil {
				return err
			}
			offset += 8
		case 3: // Lon
			// Unmarshal fixed field (Lon)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.Lon); err != nil {
				return err
			}
			offset += 8
		}
	}

	return nil
}

func (m *GetRecommendationsResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *GetRecommendationsResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item data: %w", err)
					}
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetRatesRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// Field 2 (InDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of InDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.InDate)))
	offset += len(m.InDate)

	// Field 3 (OutDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of OutDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.OutDate)))
	offset += len(m.OutDate)

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	// Write string or bytes field (InDate)
	buf.Write([]byte(m.InDate))

	// Write string or bytes field (OutDate)
	buf.Write([]byte(m.OutDate))

	return buf.Bytes(), nil
}

func (m *GetRatesRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 3)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 3; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item data: %w", err)
					}
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				offset += int(entry.length)
			}
		case 2: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[2]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[3]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetRatesResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedRepeatedMessages := make(map[byte][][]byte)
	// Cache field 1 (RatePlans): repeated message
	cachedRepeatedMessages[1] = make([][]byte, len(m.RatePlans))
	for i, item := range m.RatePlans {
		if item != nil {
			cachedRepeatedMessages[1][i], err = item.MarshalSymphony()
		}
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (RatePlans): nested message
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	totalLen := 0
	for _, item := range cachedRepeatedMessages[1] {
		totalLen += 4 + len(item) // 4 bytes for length + message data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write nested message field (RatePlans)
	for _, item := range cachedRepeatedMessages[1] {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write(item)
	}

	return buf.Bytes(), nil
}

func (m *GetRatesResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // RatePlans
			// Unmarshal nested message field (RatePlans)
			if entry, ok := offsets[1]; ok {
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				m.RatePlans = make([]*RatePlan, 0)
				itemReader := bytes.NewReader(fieldData)
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return err
					}
					itemBytes := make([]byte, itemLen)
					if _, err := itemReader.Read(itemBytes); err != nil {
						return err
					}
					newItem := &RatePlan{}
					if itemLen == 0 {
						m.RatePlans = append(m.RatePlans, nil)
						continue
					}
					if err := newItem.UnmarshalSymphony(itemBytes); err != nil {
						return err
					}
					m.RatePlans = append(m.RatePlans, newItem)
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RatePlan) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5})

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 5 (RoomType): singular message
	if m.RoomType != nil {
		cachedSingularMessages[5], err = m.RoomType.MarshalSymphony()
		if err != nil {
			return nil, err
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelId): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelId
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.HotelId)))
	offset += len(m.HotelId)

	// Field 2 (Code): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Code
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Code)))
	offset += len(m.Code)

	// Field 3 (InDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of InDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.InDate)))
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of OutDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.OutDate)))
	offset += len(m.OutDate)

	// Field 5 (RoomType): nested message
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset))
	binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[5])))
	offset += len(cachedSingularMessages[5])

	// === DATA REGION SECTION ===

	// Write string or bytes field (HotelId)
	buf.Write([]byte(m.HotelId))

	// Write string or bytes field (Code)
	buf.Write([]byte(m.Code))

	// Write string or bytes field (InDate)
	buf.Write([]byte(m.InDate))

	// Write string or bytes field (OutDate)
	buf.Write([]byte(m.OutDate))

	// Write nested message field (RoomType)
	buf.Write(cachedSingularMessages[5])

	return buf.Bytes(), nil
}

func (m *RatePlan) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 5)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 5; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelId
			// Unmarshal string or []byte field (HotelId)
			if entry, ok := offsets[1]; ok {
				m.HotelId = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Code
			// Unmarshal string or []byte field (Code)
			if entry, ok := offsets[2]; ok {
				m.Code = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // RoomType
			// Unmarshal nested message field (RoomType)
			if entry, ok := offsets[5]; ok {
				if entry.length == 0 {
					m.RoomType = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.RoomType == nil {
						m.RoomType = &RoomType{}
					}
					if err := m.RoomType.UnmarshalSymphony(fieldData); err != nil {
						return err
					}
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RoomType) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5, 6})

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 8 // BookableRate

	offset += 8 // TotalRate

	offset += 8 // TotalRateInclusive

	// Field 4 (Code): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Code
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Code)))
	offset += len(m.Code)

	// Field 5 (Currency): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Currency
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Currency)))
	offset += len(m.Currency)

	// Field 6 (RoomDescription): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of RoomDescription
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.RoomDescription)))
	offset += len(m.RoomDescription)

	// === DATA REGION SECTION ===

	// Write fixed field (BookableRate)
	binary.Write(&buf, binary.LittleEndian, m.BookableRate)

	// Write fixed field (TotalRate)
	binary.Write(&buf, binary.LittleEndian, m.TotalRate)

	// Write fixed field (TotalRateInclusive)
	binary.Write(&buf, binary.LittleEndian, m.TotalRateInclusive)

	// Write string or bytes field (Code)
	buf.Write([]byte(m.Code))

	// Write string or bytes field (Currency)
	buf.Write([]byte(m.Currency))

	// Write string or bytes field (RoomDescription)
	buf.Write([]byte(m.RoomDescription))

	return buf.Bytes(), nil
}

func (m *RoomType) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 6)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 3; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // BookableRate
			// Unmarshal fixed field (BookableRate)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.BookableRate); err != nil {
				return err
			}
			offset += 8
		case 2: // TotalRate
			// Unmarshal fixed field (TotalRate)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.TotalRate); err != nil {
				return err
			}
			offset += 8
		case 3: // TotalRateInclusive
			// Unmarshal fixed field (TotalRateInclusive)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+8]), binary.LittleEndian, &m.TotalRateInclusive); err != nil {
				return err
			}
			offset += 8
		case 4: // Code
			// Unmarshal string or []byte field (Code)
			if entry, ok := offsets[4]; ok {
				m.Code = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // Currency
			// Unmarshal string or []byte field (Currency)
			if entry, ok := offsets[5]; ok {
				m.Currency = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 6: // RoomDescription
			// Unmarshal string or []byte field (RoomDescription)
			if entry, ok := offsets[6]; ok {
				m.RoomDescription = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *ReservationRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (CustomerName): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of CustomerName
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.CustomerName)))
	offset += len(m.CustomerName)

	// Field 2 (HotelId): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelId
	totalLen := 0
	for _, item := range m.HotelId {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// Field 3 (InDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of InDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.InDate)))
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of OutDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.OutDate)))
	offset += len(m.OutDate)

	offset += 4 // RoomNumber

	// === DATA REGION SECTION ===

	// Write string or bytes field (CustomerName)
	buf.Write([]byte(m.CustomerName))

	// Write repeated variable-length field (HotelId)
	for _, item := range m.HotelId {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	// Write string or bytes field (InDate)
	buf.Write([]byte(m.InDate))

	// Write string or bytes field (OutDate)
	buf.Write([]byte(m.OutDate))

	// Write fixed field (RoomNumber)
	binary.Write(&buf, binary.LittleEndian, m.RoomNumber)

	return buf.Bytes(), nil
}

func (m *ReservationRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 5)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 4; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // CustomerName
			// Unmarshal string or []byte field (CustomerName)
			if entry, ok := offsets[1]; ok {
				m.CustomerName = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // HotelId
			// Unmarshal repeated variable-length field (HotelId)
			if entry, ok := offsets[2]; ok {
				m.HotelId = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelId (2): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelId = append(m.HotelId, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelId (2): error reading item data: %w", err)
					}
					m.HotelId = append(m.HotelId, string(itemData))
				}
				offset += int(entry.length)
			}
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 5: // RoomNumber
			// Unmarshal fixed field (RoomNumber)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.RoomNumber); err != nil {
				return err
			}
			offset += 4
		}
	}

	return nil
}

func (m *ReservationResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelId): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelId
	totalLen := 0
	for _, item := range m.HotelId {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelId)
	for _, item := range m.HotelId {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *ReservationResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelId
			// Unmarshal repeated variable-length field (HotelId)
			if entry, ok := offsets[1]; ok {
				m.HotelId = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelId (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelId = append(m.HotelId, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelId (1): error reading item data: %w", err)
					}
					m.HotelId = append(m.HotelId, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4})

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Lat

	offset += 4 // Lon

	// Field 3 (InDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of InDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.InDate)))
	offset += len(m.InDate)

	// Field 4 (OutDate): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of OutDate
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.OutDate)))
	offset += len(m.OutDate)

	// === DATA REGION SECTION ===

	// Write fixed field (Lat)
	binary.Write(&buf, binary.LittleEndian, m.Lat)

	// Write fixed field (Lon)
	binary.Write(&buf, binary.LittleEndian, m.Lon)

	// Write string or bytes field (InDate)
	buf.Write([]byte(m.InDate))

	// Write string or bytes field (OutDate)
	buf.Write([]byte(m.OutDate))

	return buf.Bytes(), nil
}

func (m *SearchRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 4)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Lat
			// Unmarshal fixed field (Lat)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lat); err != nil {
				return err
			}
			offset += 4
		case 2: // Lon
			// Unmarshal fixed field (Lon)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Lon); err != nil {
				return err
			}
			offset += 4
		case 3: // InDate
			// Unmarshal string or []byte field (InDate)
			if entry, ok := offsets[3]; ok {
				m.InDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // OutDate
			// Unmarshal string or []byte field (OutDate)
			if entry, ok := offsets[4]; ok {
				m.OutDate = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SearchResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write repeated variable-length field (HotelIds)
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *SearchResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 1; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // HotelIds
			// Unmarshal repeated variable-length field (HotelIds)
			if entry, ok := offsets[1]; ok {
				m.HotelIds = make([]string, 0)
				itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])
				for itemReader.Len() > 0 {
					var itemLen uint32
					if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item length: %w", err)
					}
					if itemLen == 0 {
						m.HotelIds = append(m.HotelIds, "")
						continue
					}
					itemData := make([]byte, itemLen)
					if _, err := itemReader.Read(itemData); err != nil {
						return fmt.Errorf("field HotelIds (1): error reading item data: %w", err)
					}
					m.HotelIds = append(m.HotelIds, string(itemData))
				}
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CheckUserRequest) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Username): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Username
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Username)))
	offset += len(m.Username)

	// Field 2 (Password): string or bytes
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Password
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Password)))
	offset += len(m.Password)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Username)
	buf.Write([]byte(m.Username))

	// Write string or bytes field (Password)
	buf.Write([]byte(m.Password))

	return buf.Bytes(), nil
}

func (m *CheckUserRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Username
			// Unmarshal string or []byte field (Username)
			if entry, ok := offsets[1]; ok {
				m.Username = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 2: // Password
			// Unmarshal string or []byte field (Password)
			if entry, ok := offsets[2]; ok {
				m.Password = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *CheckUserResult) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer

	// === HEADER SECTION ===
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 1 // Correct

	// === DATA REGION SECTION ===

	// Write fixed field (Correct)
	binary.Write(&buf, binary.LittleEndian, m.Correct)

	return buf.Bytes(), nil
}

func (m *CheckUserResult) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 0; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Correct
			// Unmarshal fixed field (Correct)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+1]), binary.LittleEndian, &m.Correct); err != nil {
				return err
			}
			offset += 1
		}
	}

	return nil
}
