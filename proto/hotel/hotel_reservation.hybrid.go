// Code generated by protoc-gen-symphony-hybrid. DO NOT EDIT.
package hotel_reservation

import (
	"encoding/binary"
	"fmt"

	"google.golang.org/protobuf/proto"
)

// -----------------Geo service-----------------

func (m *NearbyRequest) MarshalSymphonyHybrid() ([]byte, error) {
	// Calculate public segment size
	publicSegmentSize := 13
	publicSegmentSize += 0 // public table

	// Marshal private fields using protobuf
	privateMsg := &NearbyRequest{
		Lat:       m.Lat,
		Lon:       m.Lon,
		Latstring: m.Latstring,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	// Calculate total size
	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	// Write header
	buf[0] = 0x01                                                      // version byte
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write private segment (Protobuf format)
	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *NearbyRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &NearbyRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Lat = privateMsg.Lat
		m.Lon = privateMsg.Lon
		m.Latstring = privateMsg.Latstring
	}
	return nil
}

func (m *NearbyResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &NearbyResult{
		HotelIds: m.HotelIds,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *NearbyResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &NearbyResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelIds = privateMsg.HotelIds
	}
	return nil
}

// -----------------Profile service-----------------

func (m *GetProfilesRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetProfilesRequest{
		HotelIds: m.HotelIds,
		Locale:   m.Locale,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetProfilesRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetProfilesRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelIds = privateMsg.HotelIds
		m.Locale = privateMsg.Locale
	}
	return nil
}

func (m *GetProfilesResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetProfilesResult{
		Hotels: m.Hotels,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetProfilesResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetProfilesResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Hotels = privateMsg.Hotels
	}
	return nil
}

func (m *Hotel) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &Hotel{
		Id:          m.Id,
		Name:        m.Name,
		PhoneNumber: m.PhoneNumber,
		Description: m.Description,
		Address:     m.Address,
		Images:      m.Images,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *Hotel) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &Hotel{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Id = privateMsg.Id
		m.Name = privateMsg.Name
		m.PhoneNumber = privateMsg.PhoneNumber
		m.Description = privateMsg.Description
		m.Address = privateMsg.Address
		m.Images = privateMsg.Images
	}
	return nil
}

func (m *Address) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &Address{
		StreetNumber: m.StreetNumber,
		StreetName:   m.StreetName,
		City:         m.City,
		State:        m.State,
		Country:      m.Country,
		PostalCode:   m.PostalCode,
		Lat:          m.Lat,
		Lon:          m.Lon,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *Address) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &Address{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.StreetNumber = privateMsg.StreetNumber
		m.StreetName = privateMsg.StreetName
		m.City = privateMsg.City
		m.State = privateMsg.State
		m.Country = privateMsg.Country
		m.PostalCode = privateMsg.PostalCode
		m.Lat = privateMsg.Lat
		m.Lon = privateMsg.Lon
	}
	return nil
}

func (m *Image) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &Image{
		Url:     m.Url,
		Default: m.Default,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *Image) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &Image{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Url = privateMsg.Url
		m.Default = privateMsg.Default
	}
	return nil
}

// -----------------Recommendation service-----------------

func (m *GetRecommendationsRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetRecommendationsRequest{
		Require: m.Require,
		Lat:     m.Lat,
		Lon:     m.Lon,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetRecommendationsRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetRecommendationsRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Require = privateMsg.Require
		m.Lat = privateMsg.Lat
		m.Lon = privateMsg.Lon
	}
	return nil
}

func (m *GetRecommendationsResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetRecommendationsResult{
		HotelIds: m.HotelIds,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetRecommendationsResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetRecommendationsResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelIds = privateMsg.HotelIds
	}
	return nil
}

// -----------------Rate service-----------------

func (m *GetRatesRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetRatesRequest{
		HotelIds: m.HotelIds,
		InDate:   m.InDate,
		OutDate:  m.OutDate,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetRatesRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetRatesRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelIds = privateMsg.HotelIds
		m.InDate = privateMsg.InDate
		m.OutDate = privateMsg.OutDate
	}
	return nil
}

func (m *GetRatesResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &GetRatesResult{
		RatePlans: m.RatePlans,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *GetRatesResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &GetRatesResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.RatePlans = privateMsg.RatePlans
	}
	return nil
}

func (m *RatePlan) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &RatePlan{
		HotelId:  m.HotelId,
		Code:     m.Code,
		InDate:   m.InDate,
		OutDate:  m.OutDate,
		RoomType: m.RoomType,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *RatePlan) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &RatePlan{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelId = privateMsg.HotelId
		m.Code = privateMsg.Code
		m.InDate = privateMsg.InDate
		m.OutDate = privateMsg.OutDate
		m.RoomType = privateMsg.RoomType
	}
	return nil
}

func (m *RoomType) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &RoomType{
		BookableRate:       m.BookableRate,
		TotalRate:          m.TotalRate,
		TotalRateInclusive: m.TotalRateInclusive,
		Code:               m.Code,
		Currency:           m.Currency,
		RoomDescription:    m.RoomDescription,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *RoomType) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &RoomType{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.BookableRate = privateMsg.BookableRate
		m.TotalRate = privateMsg.TotalRate
		m.TotalRateInclusive = privateMsg.TotalRateInclusive
		m.Code = privateMsg.Code
		m.Currency = privateMsg.Currency
		m.RoomDescription = privateMsg.RoomDescription
	}
	return nil
}

// -----------------Reservation service-----------------

func (m *ReservationRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &ReservationRequest{
		CustomerName: m.CustomerName,
		HotelId:      m.HotelId,
		InDate:       m.InDate,
		OutDate:      m.OutDate,
		RoomNumber:   m.RoomNumber,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *ReservationRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &ReservationRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.CustomerName = privateMsg.CustomerName
		m.HotelId = privateMsg.HotelId
		m.InDate = privateMsg.InDate
		m.OutDate = privateMsg.OutDate
		m.RoomNumber = privateMsg.RoomNumber
	}
	return nil
}

func (m *ReservationResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &ReservationResult{
		HotelId: m.HotelId,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *ReservationResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &ReservationResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelId = privateMsg.HotelId
	}
	return nil
}

// -----------------Search service-----------------

func (m *SearchRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &SearchRequest{
		Lat:     m.Lat,
		Lon:     m.Lon,
		InDate:  m.InDate,
		OutDate: m.OutDate,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *SearchRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &SearchRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Lat = privateMsg.Lat
		m.Lon = privateMsg.Lon
		m.InDate = privateMsg.InDate
		m.OutDate = privateMsg.OutDate
	}
	return nil
}

func (m *SearchResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &SearchResult{
		HotelIds: m.HotelIds,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *SearchResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &SearchResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.HotelIds = privateMsg.HotelIds
	}
	return nil
}

// -----------------User service-----------------

func (m *CheckUserRequest) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &CheckUserRequest{
		Username: m.Username,
		Password: m.Password,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *CheckUserRequest) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &CheckUserRequest{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Username = privateMsg.Username
		m.Password = privateMsg.Password
	}
	return nil
}

func (m *CheckUserResult) MarshalSymphonyHybrid() ([]byte, error) {
	publicSegmentSize := 13

	privateMsg := &CheckUserResult{
		Correct: m.Correct,
	}
	privateData, err := proto.Marshal(privateMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal private segment: %w", err)
	}

	totalSize := publicSegmentSize + len(privateData)
	buf := make([]byte, totalSize)

	buf[0] = 0x01
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize))
	binary.LittleEndian.PutUint32(buf[5:9], 0)
	binary.LittleEndian.PutUint32(buf[9:13], 0)

	copy(buf[publicSegmentSize:], privateData)

	return buf, nil
}

func (m *CheckUserResult) UnmarshalSymphonyHybrid(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))

	if offsetToPrivate < len(data) {
		privateData := data[offsetToPrivate:]
		privateMsg := &CheckUserResult{}
		if err := proto.Unmarshal(privateData, privateMsg); err != nil {
			return fmt.Errorf("failed to unmarshal private segment: %w", err)
		}
		m.Correct = privateMsg.Correct
	}
	return nil
}
