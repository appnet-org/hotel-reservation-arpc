// Code generated by protoc-gen-symphony. DO NOT EDIT.
package user

import (
	"bytes"
	"encoding/binary"
)

func (m *Request) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer
	// Layout header and field ordering
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// Calculate offsets for variable-length fields
	offset := 0

	// Field 1 (Username): string
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Username
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Username)))
	offset += len(m.Username)
	// Field 2 (Password): string
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Password
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Password)))
	offset += len(m.Password)

	// Write actual field data
	// Write string field Username
	buf.Write([]byte(m.Username))
	// Write string field Password
	buf.Write([]byte(m.Password))

	return buf.Bytes(), nil
}

func (m *Request) UnmarshalSymphony(data []byte) error {
	// Parse header and field ordering
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// Parse offset table for variable-length fields
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// Extract data region (everything after the offset table)
	dataRegion := data[len(data)-reader.Len():]

	// Unmarshal individual fields
	// Unmarshal string field Username (field 1)
	if entry, ok := offsets[1]; ok {
		m.Username = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field Password (field 2)
	if entry, ok := offsets[2]; ok {
		m.Password = string(dataRegion[entry.offset : entry.offset+entry.length])
	}

	return nil
}

func (m *Result) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer
	// Layout header and field ordering
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1})

	// Calculate offsets for variable-length fields
	offset := 0
	offset += 1 // Correct

	// Write actual field data
	// Write fixed field Correct
	binary.Write(&buf, binary.LittleEndian, m.Correct)

	return buf.Bytes(), nil
}

func (m *Result) UnmarshalSymphony(data []byte) error {
	// Parse header and field ordering
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 1)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// Parse offset table for variable-length fields
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 0; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// Extract data region (everything after the offset table)
	dataRegion := data[len(data)-reader.Len():]

	// Unmarshal individual fields
	// Unmarshal fixed field Correct (field 1)
	if err := binary.Read(bytes.NewReader(dataRegion[0:1]), binary.LittleEndian, &m.Correct); err != nil {
		return err
	}

	return nil
}
