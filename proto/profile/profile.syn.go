// Code generated by protoc-gen-symphony. DO NOT EDIT.
package profile

import (
	"bytes"
	"encoding/binary"
)

func (m *Request) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer
	// Layout header and field ordering
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2})

	// Calculate offsets for variable-length fields
	offset := 0

	// Field 1 (HotelIds): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of HotelIds
	totalLen := 0
	for _, item := range m.HotelIds {
		totalLen += 4 + len(item) // 4 bytes for length + string data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen
	// Field 2 (Locale): string
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Locale
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Locale)))
	offset += len(m.Locale)

	// Write actual field data
	// Write repeated variable-length field HotelIds data
	for _, item := range m.HotelIds {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}
	// Write string field Locale
	buf.Write([]byte(m.Locale))

	return buf.Bytes(), nil
}

func (m *Request) UnmarshalSymphony(data []byte) error {
	// Parse header and field ordering
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 2)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// Parse offset table for variable-length fields
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// Extract data region (everything after the offset table)
	dataRegion := data[len(data)-reader.Len():]

	// Unmarshal individual fields
	// Unmarshal repeated variable-length field HotelIds (field 1)
	if entry, ok := offsets[1]; ok {
		// Initialize slice
		m.HotelIds = make([]string, 0)
		// Read repeated field data
		dataStart := entry.offset
		dataEnd := entry.offset + entry.length

		// Handle empty repeated field case
		if dataEnd > dataStart {
			itemReader := bytes.NewReader(dataRegion[dataStart:dataEnd])
			bytesRead := uint16(0)
			for bytesRead < entry.length {
				var itemLen uint32
				if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
					return err
				}
				bytesRead += 4 // length of uint32

				// Handle empty string case
				if itemLen == 0 {
					m.HotelIds = append(m.HotelIds, "")
					continue
				}

				itemData := make([]byte, itemLen)
				if _, err := itemReader.Read(itemData); err != nil {
					return err
				}
				bytesRead += uint16(itemLen)
				m.HotelIds = append(m.HotelIds, string(itemData))
			}
		}
	}
	// Unmarshal string field Locale (field 2)
	if entry, ok := offsets[2]; ok {
		m.Locale = string(dataRegion[entry.offset : entry.offset+entry.length])
	}

	return nil
}

func (m *Result) MarshalSymphony() ([]byte, error) {
	var buf bytes.Buffer
	// Layout header and field ordering
	buf.WriteByte(0x00) // layout header
	buf.Write([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13})

	// Calculate offsets for variable-length fields
	offset := 0
	offset += 4 // Lat
	offset += 4 // Lon

	// Field 1 (Id): string
	binary.Write(&buf, binary.LittleEndian, byte(1))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Id
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Id)))
	offset += len(m.Id)
	// Field 2 (Name): string
	binary.Write(&buf, binary.LittleEndian, byte(2))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Name
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Name)))
	offset += len(m.Name)
	// Field 3 (PhoneNumber): string
	binary.Write(&buf, binary.LittleEndian, byte(3))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of PhoneNumber
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.PhoneNumber)))
	offset += len(m.PhoneNumber)
	// Field 4 (Description): string
	binary.Write(&buf, binary.LittleEndian, byte(4))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Description
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Description)))
	offset += len(m.Description)
	// Field 5 (StreetNumber): string
	binary.Write(&buf, binary.LittleEndian, byte(5))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of StreetNumber
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.StreetNumber)))
	offset += len(m.StreetNumber)
	// Field 6 (StreetName): string
	binary.Write(&buf, binary.LittleEndian, byte(6))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of StreetName
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.StreetName)))
	offset += len(m.StreetName)
	// Field 7 (City): string
	binary.Write(&buf, binary.LittleEndian, byte(7))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of City
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.City)))
	offset += len(m.City)
	// Field 8 (State): string
	binary.Write(&buf, binary.LittleEndian, byte(8))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of State
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.State)))
	offset += len(m.State)
	// Field 9 (Country): string
	binary.Write(&buf, binary.LittleEndian, byte(9))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of Country
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.Country)))
	offset += len(m.Country)
	// Field 10 (PostalCode): string
	binary.Write(&buf, binary.LittleEndian, byte(10))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of PostalCode
	binary.Write(&buf, binary.LittleEndian, uint16(len(m.PostalCode)))
	offset += len(m.PostalCode)
	// Field 13 (ImagesUrl): repeated variable-length
	binary.Write(&buf, binary.LittleEndian, byte(13))
	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of ImagesUrl
	totalLen := 0
	for _, item := range m.ImagesUrl {
		totalLen += 4 + len(item) // 4 bytes for length + string data
	}
	binary.Write(&buf, binary.LittleEndian, uint16(totalLen))
	offset += totalLen

	// Write actual field data
	// Write string field Id
	buf.Write([]byte(m.Id))
	// Write string field Name
	buf.Write([]byte(m.Name))
	// Write string field PhoneNumber
	buf.Write([]byte(m.PhoneNumber))
	// Write string field Description
	buf.Write([]byte(m.Description))
	// Write string field StreetNumber
	buf.Write([]byte(m.StreetNumber))
	// Write string field StreetName
	buf.Write([]byte(m.StreetName))
	// Write string field City
	buf.Write([]byte(m.City))
	// Write string field State
	buf.Write([]byte(m.State))
	// Write string field Country
	buf.Write([]byte(m.Country))
	// Write string field PostalCode
	buf.Write([]byte(m.PostalCode))
	// Write fixed field Lat
	binary.Write(&buf, binary.LittleEndian, m.Lat)
	// Write fixed field Lon
	binary.Write(&buf, binary.LittleEndian, m.Lon)
	// Write repeated variable-length field ImagesUrl data
	for _, item := range m.ImagesUrl {
		binary.Write(&buf, binary.LittleEndian, uint32(len(item)))
		buf.Write([]byte(item))
	}

	return buf.Bytes(), nil
}

func (m *Result) UnmarshalSymphony(data []byte) error {
	// Parse header and field ordering
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return err
	}

	fieldOrder := make([]byte, 13)
	if _, err := reader.Read(fieldOrder); err != nil {
		return err
	}

	// Parse offset table for variable-length fields
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 11; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return err
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return err
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// Extract data region (everything after the offset table)
	dataRegion := data[len(data)-reader.Len():]

	// Unmarshal individual fields
	// Unmarshal string field Id (field 1)
	if entry, ok := offsets[1]; ok {
		m.Id = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field Name (field 2)
	if entry, ok := offsets[2]; ok {
		m.Name = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field PhoneNumber (field 3)
	if entry, ok := offsets[3]; ok {
		m.PhoneNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field Description (field 4)
	if entry, ok := offsets[4]; ok {
		m.Description = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field StreetNumber (field 5)
	if entry, ok := offsets[5]; ok {
		m.StreetNumber = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field StreetName (field 6)
	if entry, ok := offsets[6]; ok {
		m.StreetName = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field City (field 7)
	if entry, ok := offsets[7]; ok {
		m.City = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field State (field 8)
	if entry, ok := offsets[8]; ok {
		m.State = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field Country (field 9)
	if entry, ok := offsets[9]; ok {
		m.Country = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal string field PostalCode (field 10)
	if entry, ok := offsets[10]; ok {
		m.PostalCode = string(dataRegion[entry.offset : entry.offset+entry.length])
	}
	// Unmarshal fixed field Lat (field 11)
	if err := binary.Read(bytes.NewReader(dataRegion[0:4]), binary.LittleEndian, &m.Lat); err != nil {
		return err
	}
	// Unmarshal fixed field Lon (field 12)
	if err := binary.Read(bytes.NewReader(dataRegion[4:8]), binary.LittleEndian, &m.Lon); err != nil {
		return err
	}
	// Unmarshal repeated variable-length field ImagesUrl (field 13)
	if entry, ok := offsets[13]; ok {
		// Initialize slice
		m.ImagesUrl = make([]string, 0)
		// Read repeated field data
		dataStart := entry.offset
		dataEnd := entry.offset + entry.length

		// Handle empty repeated field case
		if dataEnd > dataStart {
			itemReader := bytes.NewReader(dataRegion[dataStart:dataEnd])
			bytesRead := uint16(0)
			for bytesRead < entry.length {
				var itemLen uint32
				if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil {
					return err
				}
				bytesRead += 4 // length of uint32

				// Handle empty string case
				if itemLen == 0 {
					m.ImagesUrl = append(m.ImagesUrl, "")
					continue
				}

				itemData := make([]byte, itemLen)
				if _, err := itemReader.Read(itemData); err != nil {
					return err
				}
				bytesRead += uint16(itemLen)
				m.ImagesUrl = append(m.ImagesUrl, string(itemData))
			}
		}
	}

	return nil
}
